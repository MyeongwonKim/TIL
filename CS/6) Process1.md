## 프로세스와 컨텍스트 스위칭

### 프로세스 구조
- 코드(text) 영역: 실행된 프로그램의 코드가 저장됨
- 데이터 영역: 변수/초기화된 데이터
  - BSS: 초기화되지 않은 전역변수가 저장됨
  - DATA: 초기값이 있는 전역변수가 저장됨
- 스택 영역: 임시 데이터 (함수 호출, 매개변수 값, 로컬변수 등)가 저장됨.
  - 상단에서부터 아래로 데이터가 쌓임
  - 함수가 실행될 경우 함수의 마지막 줄이 return address로 먼저 들어오고, 매개변수나 로컬변수 값 등이 스택에 들어옴 -> 그런 다음 함수가 종료되면 아래에서부터 차례대로 저장된 값을 지우고 상단에 있는 address로 돌아감
  - C언어에서는 main함수의 마지막 줄이 먼저 return address로 스택의 최상단에 들어감
- 힙 영역: 코드에서 동적으로 만들어지는 데이터 (별도의 공간을 할당받을 수 있음)
  - ex) C언어의 malloc(sizeof(int)) : 힙 영역에 32bit의 공간을 할당하고 그 주소를 반환 

### 프로세스 실행
- 프로그램 카운터: 실행할 명령의 주소를 갖고있는 CPU register. 코드 영역을 한줄씩 순서대로 가리킴
- 스택 포인터: 프로그램의 마지막 요청에 대한 주소를 갖고있는 CPU 스택 register (사실은 그 다음 공란을 가리킴)
- EBP: 스택의 최상단 주소값을 가지는 register. 함수가 순차적으로 실행되데가 에러 발생시 어디서 문제가 생겼는지 빠르게 찾기 위해 사용됨  
- EAX: 함수의 반환값이 담기는 register

### 컨텍스트 스위칭
- CPU에서 실행 중인 프로세스를 교체하는 기술
- 실행 중이던 프로세스의 PC, SP를 PCB에 업데이트하여 메인 메모리에 저장 -> 실행할 프로세스의 PCB 내의 정보를 CPU에 넣고 실행
- PCB(Process Control Block): 프로세스가 실행 중인 상태를 캡처/구조화하여 저장
  - Process ID, register값(PC, SP), Scheduling info(Process State), Memory info (메모리 사이즈 limit) 등이 저장됨
- 굉장히 짧은 시간 단위로 컨텍스트 스위칭이 일어남 (10ms 정도..)

### cf) 컴파일러 vs 어셈블리어
- 초기 컴퓨터 프로그램들은 어셈블리어로 작성됨. 하지만 새로운 CPU 아키텍처가 등장할 때 마다 그에 맞는 프로그램을 작성해야함 (이식성이 떨어짐)
- 컴파일러가 등장하면서 새로운 CPU 아키텍처에 맞는 컴파일러만 만들면 기존 프로그램 코드는 변경할 필요가 없게 됨
- 그러나 컨텍스트 스위칭의 경우 속도가 중요하기 때문에 어셈블리어로 작성됨 (리눅스)
