## 가상 메모리 기초
### 기본 개념
- 메모리 용량 제한 문제 때문에 각 프로세스가 현재 사용하는 공간만 물리적인 메모리에 저장하는 방식이 필요함
- 기본 아이디어: 전체 프로세스는 가장 주소를 참조하며 사용 중인 부분만 물리 주소에 저장. 실제 해당 주소에서 데이터를 읽고 쓸때만 가상 주소를 물리 주소로 바꿔주면된다.
- CPU는 가상 메모리를 다루고, 실제 해당 주소 접근시 MMU를 통해 물리 메모리에 접근
- MMU (Memory Management Unit): 가상 주소를 물리 주소값으로 빠르게 변환해주는 하드웨어 장치

### 페이징 시스템
- 페이징: 가상 메모리 공간을 페이지 단위로 나누고, 페이지 별로 물리 메모리에 저장 (리눅스에서는 4KB)
- Page Table: 페이지 번호 별로 가상 주소와 물리 주소를 mapping 해놓은 것 (실제 물리 주소에 있는지를 나타내는 valid 정보도 있음). 프로세스의 PCB에는 Page Table의 주소가 있고 Page Table의 정보는 물리 메모리에 저장됨. 프로세스 구동시 CR3라는 레지스터에 별도로 page table의 base 주소가 저장됨
- 가상 주소 (32bit) = (p, d)
  - p: 가상 메모리 페이지
  - d: p 안에서 참조하는 위치 (변위)
- paging system 동작: 해당 프로세스의 page table에 원하는 page 번호가 있는지 확인 -> 있는 경우 page가 mapping된 첫 물리 주소를 알아냄(p') -> p'+d가 실제 물리 주소가 됨

### 다중 단계 페이징 시스템
- 페이징 정보를 단계를 나누어 생성 (필요 없는 페이지는 생성하지 않아서 공간 절약)
- 페이지 번호를 나타내는 bit 중 변위 12bit를 제외하고, 앞의 20bit를 나누어서 단계를 나눔

### MMU와 TLB
- 실제 메모리 접근 방식: CPU 특정 프로세스의 가상 메모리 주소 요청 -> MMU가 CR3 레지스터 값에 접근하여 해당 프로세스의 page table에 접근 -> 해당 데이터의 물리 주소 가져옴 -> MMU가 해당 데이터의 물리 주소에 접근 -> 메모리가 해당 데이터를 CPU에 전달
