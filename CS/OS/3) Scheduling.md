## 프로세스 스케쥴링

### 배치 처리 시스템
- 자동으로 여러 응용 프로그램이 순차적으로 실행될 수 있도록 하는 시스템
- 큐의 구조와 비슷
- 문제점
  - 어떤 프로그램의 실행 시간이 너무 길면 다음 프로그램 실행 시간이 너무 오래 걸림
  - 동시에 둘 이상의 프로그램을 실행할 수 없음
  - 여러 사용자가 동시에 컴퓨터를 사용할 수 없음

### 시분할 시스템
- 다중 사용자 지원을 위해 컴퓨터 응답 시간을 최소화하는 시스템
- 응용 프로그램이 CPU를 점유하는 시간을 잘게 쪼개어 실행될 수 있도록 함

### 멀티 태스킹
- 단일 CPU에서 여러 응용 프로그램이 동시에 실행되는 것처럼 보이도록 하는 시스템
- 10~20ms 단위로 실행 응용 프로그램이 바뀌면 사용자에겐 동시 실행으로 보임
- **멀티 프로세싱**: 여러 CPU에 하나의 프로그램을 병렬로 실행하여 실행속도를 극대화함

### 멀티 프로그래밍
- 시간 대비 최대한 CPU를 많이 활용하도록 하는 시스템
  - 여러 응용 프로그램을 짧은 시간 안에 실행 완료시키기 위해
  - 응용 프로그램 실행 중에 CPU를 사용하지 않는 시간도 있음 ex) 파일 읽기/ 프린팅하는 동안 -> 이 때 다른 응용 프로그램이 CPU를 사용하도록 함
  
## 스케쥴링 알고리즘

### 프로세스
- 정의: 메모리에 올려져서 실행 중인 프로그램. 작업/task/job 용어와 혼용
- 코드 이미지(binary): 실행 파일
- 응용 프로그램은 여러 개의 프로세스로 이루어질 수 있음 (IPC기법을 이용하여 서로 통신하면서 실행됨)

### 스케쥴러
- 정의: 특정 순서대로 프로세스가 실행되도록 관리함
- FIFO 스케쥴러: FCFS(First Come First Served)
  - 배치 처리 시스템과 유사함
  - 문제점: 실행시간이 긴 프로세스가 먼저 도달하면 효율성이 떨어짐
- 최단 작업 (SJF, Shortest Job First) 스케쥴러
  - 실행시간이 짧은 프로세스 먼저 실행
  - 문제점: 실행시간이 긴 프로세스는 CPU를 할당받는 것이 불가능해질 수 있음. 실행시간을 모두 알아야 구현 가능
- 우선 순위 기반 스케쥴러 (Priority-Based)
  - 정적 우선순위: 프로세스 마다 미리 지정 / 동적 우선순위: 스케쥴러가 상황에 따라 우선순위를 변경
  - 선점형 스케쥴링 방식: 더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈춤
  - 비선점형 스케쥴링 방식: 더 높은 우선순위의 프로세스가 도착하면 Ready Queue의 Head에 넣음
  - 문제점: 우선순위가 낮은 프로세스의 경우 무기한 blocking 상태에 빠질 수 있음
- Round Robin 스케쥴러
  - time quantum 만큼 실행 후 해당 프로세스를 ready queue의 마지막으로 보내는 방식. 현대적인 CPU 스케쥴링
  - **시분할 시스템**을 기반으로 함
  - 장점: response time이 빨라짐
  - 주의할 점: time quantum이 너무 커지면 FCFS와 같아짐. 너무 작을 경우 잦은 context switch로 overhead가 발생할 수 있음

#### RTOS vs GPOS
- RealTime OS: 프로그램 실시간 성능 보장을 목표로 하는 OS. 프로그램의 시작, 완료 시간을 보장
- General Purpose OS: 실행시간에 민감하지 않고 일반적인 목적으로 사용되는 OS
