## 프로세스와 컨텍스트 스위칭

### 프로세스 구조
- 코드(text) 영역: 실행된 프로그램의 코드가 저장됨
- 데이터 영역: 변수/초기화된 데이터
  - BSS: 초기화되지 않은 전역변수가 저장됨
  - DATA: 초기값이 있는 전역변수가 저장됨
- 스택 영역: 임시 데이터 (함수 호출, 매개변수 값, 로컬변수 등)가 저장됨.
  - 상단에서부터 아래로 데이터가 쌓임
  - 함수가 실행될 경우 함수의 마지막 줄이 return address로 먼저 들어오고, 매개변수나 로컬변수 값 등이 스택에 들어옴 -> 그런 다음 함수가 종료되면 아래에서부터 차례대로 저장된 값을 지우고 상단에 있는 address로 돌아감
  - C언어에서는 main함수의 마지막 줄이 먼저 return address로 스택의 최상단에 들어감
- 힙 영역: 코드에서 동적으로 만들어지는 데이터 (별도의 공간을 할당받을 수 있음)
  - ex) C언어의 malloc(sizeof(int)) : 힙 영역에 32bit의 공간을 할당하고 그 주소를 반환 

### 프로세스 실행
- 프로그램 카운터: 실행할 명령의 주소를 갖고있는 CPU register. 코드 영역을 한줄씩 순서대로 가리킴
- 스택 포인터: 프로그램의 마지막 요청에 대한 주소를 갖고있는 CPU 스택 register (사실은 그 다음 공란을 가리킴)
- EBP: 스택의 최상단 주소값을 가지는 register. 함수가 순차적으로 실행되데가 에러 발생시 어디서 문제가 생겼는지 빠르게 찾기 위해 사용됨  
- EAX: 함수의 반환값이 담기는 register

### 컨텍스트 스위칭
- CPU에서 실행 중인 프로세스를 교체하는 기술
- 실행 중이던 프로세스의 PC, SP를 PCB에 업데이트하여 메인 메모리에 저장 -> 실행할 프로세스의 PCB 내의 정보를 CPU에 넣고 실행
- PCB(Process Control Block): 프로세스가 실행 중인 상태를 캡처/구조화하여 저장
  - Process ID, register값(PC, SP), Scheduling info(Process State), Memory info (메모리 사이즈 limit) 등이 저장됨
- 굉장히 짧은 시간 단위로 컨텍스트 스위칭이 일어남 (10ms 정도..)

### cf) 컴파일러 vs 어셈블리어
- 초기 컴퓨터 프로그램들은 어셈블리어로 작성됨. 하지만 새로운 CPU 아키텍처가 등장할 때 마다 그에 맞는 프로그램을 작성해야함 (이식성이 떨어짐)
- 컴파일러가 등장하면서 새로운 CPU 아키텍처에 맞는 컴파일러만 만들면 기존 프로그램 코드는 변경할 필요가 없게 됨
- 그러나 컨텍스트 스위칭의 경우 속도가 중요하기 때문에 어셈블리어로 작성됨 (리눅스)

## 프로세스 정리
- 예시:  open() 함수 호출이 포함된 C언어 코드

<img src=https://user-images.githubusercontent.com/65876994/92083088-6cbda500-ee00-11ea-9847-f4043a05ccc4.PNG width=700 height=500>

프로그램 작성 -> 컴파일하면 실행파일이 생성됨 -> shell을 통해 실행 파일 실행 요청  
-> 프로세스가 ready 상태로 등록됨 -> 스케쥴러 정책에 맞추어서 인터럽트에 의해 컨텍스트 스위칭 발생  
-> 해당 프로세스가 running 상태가 됨 (PCB 정보를 CPU에 전달하고 실행 시작) -> CODE를 한줄 씩 실행  
-> open() 함수 호출
#### open()의 실제 코드
```C
mov eax, 1  // 시스템콜 번호
mov ebx, 0  // 인자
int 0x80    // 인터럽트 번호
```
-> 사용자 모드에서 커널 모드로 전환 -> IDT에서 0x80에 해당하는 주소를 찾아서 인터럽트 함수 실행  
-> eax로 부터 시스템콜 번호를 찾아서 해당 번호에 맞는 시스템콜 함수 호출 ( sys_open() )  
-> 프로세스는 block 상태가 됨 -> 저장매체로부터 파일 읽기가 완료되면 다시 인터럽트 발생  
-> 프로세스는 ready 상태가 되고 컨텍스트 스위칭에 의해 running 상태가 됨 (사용자 모드로 전환)  
-> open() 함수 이후의 프로그램 코드를 계속 실행

- cf) 빈번한 IO 처리 -> 많은 인터럽트, 시스템콜, 저장매체 처리를 일으켜서 실행 속도를 

## 프로세스 간 커뮤니케이션 (IPC)
- 원칙적으로는 다른 프로세스의 코드나 메모리 영역에 접근할 수는 없음

### 필요한 경우의 예시
- 프로세스 fork()를 통한 병렬 연산 처리 -> 프로세스 간 통신을 통해 결과 통합 필요
- 웹 서버가 CPU 병렬 처리를 통해 많은 클라이언트의 요청을 동시에 처리 -> 이 때에도 통합적인 제어 및 상태 정보 교화을 위해 프로세스간 통신이 필요

### 프로세스의 공간
- 가상 메모리 내에 저장됨 (각 프로세스 당 4Gb)
  - 0~3Gb: 사용자 모드의 프로그램 정보가 저장됨. 각 프로세스가 고유의 공간을 가짐
  - 3~4Gb: 커널 공간. 운영체제와 관련된 코드. 이 공간은 프로세스 간 공유가 가능함 

### 다양한 IPC 기법 **(참고용 내용)**
1) file 사용: 저장매체를 사용하기 때문에 실시간성 떨어짐
2) shared memory, pipe, signal, socket 등: 공유된 커널 공간을 사용하여 통신함

#### pipe
- fork()로 자식 프로세스를 만들었을 때, 부모 -> 자식 단방향의 통신
- pid = fork() 실행시 부모 프로세스의 pid는 실제 프로세스 ID가 들어가고, 자식 프로세스는 pid로 0이 들어감
- 부모 프로세스가 전송한 데이터는 파이프(커널 공간)에 저장되었다가 자식 프로세스로 전달됨

```C
char* msg = "Hello Child Process!"; 
int main() {     
  char buf[255];     
  int fd[2], pid, nbytes;     
  if (pipe(fd) < 0)       // pipe(fd): 파이프 생성             
    exit(1);     
  pid = fork();           // 이 코드 다음부터 부모/자식 프로세스로 나누어짐
  if (pid > 0) {          // 부모 프로세스에서는 write 수행
    write(fd[1], msg, MSGSIZE);  // fd[1]에 msg를 씀
    exit(0);    
  }     
  else {                  // 자식 프로세스에서는 read 수행
    nbytes = read(fd[0], buf, MSGSIZE);  // fd[0]에서 msg를 buf로 받음
    printf("%d %s\n", nbytes, buf);    // buf에 받은 내용 출력
    exit(0);    
  }     
return 0; }
```
#### 메시지 큐
- 부모/자식 간이 아닌 어떤 프로세스 간에서 송수신 가능. 양방향 가능
- 커널 공간의 메모리를 사용함

1) 프로세스 A (메시지 전송)
```C
msqid = msgget(key, msgflg) // key 1234
msgsnd(msqid, &sbuf, buf_length, IPC_NOWAIT) // sbuf의 내용을 key 1234의 msg queue로 보냄
```
2) 프로세스 B (메시지 전달 받음)
```C
msqid = msgget(key, msgflg) // 동일한 key 1234 사용
msgrcv(msqid, &rbuf, MSGSZ, 1, 0) // key 1234의 msg queue로 전송된 내용을 rbuf에 받아서 저장
```

#### 공유 메모리
- 커널 공간에 특정 공간을 만들고, 해당 공간의 주소를 마치 변수처럼 사용함
- 공유메모리 key를 가지고 여러 프로세스가 접근 가능

1) 공유 메모리 생성 및 주소 얻기
```C
shmid = shmget((key_t)1234, SIZE, IPC_CREAT|0666)) 
shmaddr = shmat(shmid, (void*)0, 0)
```

2) 공유 메모리에 쓰기
```C
strcpy((char *)shmaddr, "Linux Programming")
```
3) 공유 메모리에서 읽기
```C
printf("%s\n", (char *)shmaddr)
```

#### signal
- 프로세스와 관련된 특정한 이벤트를 가리킴. 유닉스에서 오랫동안 사용되어옴
- 시그널에 시그널 핸들러를 등록하여 특정 동작을 수행하게 함
- 커널 모드에서 사용자 모드로 전환되기 전에 시그널을 확인하여 처리함 (기본 동작 또는 사용자 정의 동작 수행)

#### 소켓
- 원래는 클라이언트와 서버 간의 네트워크 기반 통신을 위한 기술임
- 하나의 컴퓨터 내에서 두 프로세스 간의 통신을 위해서도 사용 가능
- 이것도 시스템 콜로서 커널 모드로 전환되어 수행됨. 커널 공간의 네트워크 기기를 이용한 통신
