
## 자료구조 & 알고리즘
- 배열과 Linked List의 차이
- BST와 최악의 시간 복잡도와 최악의 시간이 걸리는 케이스
- Hash Table
- Fibonacci 공식을 recursive 방식과 DP 방식으로 구현시의 차이점
- DFS와 BFS
- 스택 2개를 큐처럼 구현
- 각 정렬의 시간복잡도 비교
<br><br><br>


### 배열과 Linked List의 차이
#### 배열
- 인덱스로 해당 원소에 접근이 가능. 따라서 인덱스로 접근할 경우 O(1)
- 원소를 중간에 삽입할 경우 나머지 원소들의 인덱스도 바뀌어야 함. 또한 정해진 크기를 갖기 때문에 다 찬 경우 내부적으로는 추가가 안 됨
- 원소를 삭제할 경우 O(n)
- 데이터에 접근하는 것이 더 중요한 경우 배열을 사용하는 것이 더 좋음

#### Linked List
- 원소에 접근하는 경우 O(n)
- 삽입과 삭제의 경우 O(n)이며 배열 보다 대체로 더 빠른 편임. 맨 앞이나 맨 뒤에 삽입 또는 삭제할 경우 O(1)
- 따라서 삽입과 삭제가 빈번한 경우 Linked List를 사용하는 것이 더 좋음

#### Java의 ArrayList
- 내부적으로 배열 형태로 데이터를 관리하며 추가, 삭제시 임시 배열을 생성해 데이터를 복사하는 방법을 사용함
- 인덱스로 접근할 경우 O(1). 배열의 끝에서 삽입과 삭제가 일어날 경우 O(1)

### BST와 최악의 시간 복잡도와 최악의 시간이 걸리는 케이스
- Binary Search Tree는 자식 노드가 최대 2개인 이진트리이면서 아래의 두 조건을 만족하는 경우임
  - 왼쪽 부속트리의 모든 노드의 값 < 루트의 값 < 오른쪽 부속트리의 모든 노드의 값
  - 모든 부속트리들도 위의 조건을 만족시킴
- 탐색, 삽입, 삭제 모두 트리의 높이 만큼 시간이 걸림. 즉 O(h). 따라서 평균적인 시간복잡도는 O(logN)
- 하지만 한쪽으로 치우친 skewed tree 형태일 경우 O(n)의 시간복잡도를 갖는다.

### Hash Table
### Fibonacci 공식을 recursive 방식과 DP 방식으로 구현시의 차이점
### DFS와 BFS
#### 트리에서의 DFS
트리에서 DFS를 사용할 경우 탐색 순서에 따라 3가지 방법으로 나뉜다.
- 전위 순회(Preorder Traversal) : 루트 -> 왼쪽 자식 -> 오른쪽 자식순으로 순회
- 중위 순회(Inorder Traversal): 왼쪽 자식 -> 루트 -> 오른쪽 자식순으로 순화
- 후위 순회(Postorder Traversal): 왼쪽 자식 -> 오른쪽 자식 -> 루트순으로 순회

### 스택 2개를 큐처럼 구현
### 각 정렬의 시간복잡도 비교


